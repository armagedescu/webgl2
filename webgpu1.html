<html>
<head>
   <title>webgpu test</title>
   <link   rel="stylesheet" href="./lib/css/default.css"></link>
   <script src="./lib/js/math/3dmath.js"></script>
   <script src="./lib/js/gl2js/glcanvas.js"></script>
   <script src="./lib/js/gpujs/gpucanvas.js"></script>
   <script src="./lib/js/experiment/experiment.js"></script>
</head>
<body>
   <pre>
adapter = await navigator.gpu.requestAdapter();
device       = await adapter.requestDevice();
context      = canvas.getContext('webgpu');

/////////// adapter
// limited to WebGPU initialization
/////////// end adapter

/////////// context
// initial configure
// Render pass descriptor, where to render (!?): context.getCurrentTexture().createView()
/////////// end context

/////////// device 
// compiles shaders, create/write buffers,  createBuffer/writeBuffer, uniformBuffers
// create renderPipeline (~link program), 
////    while (draw) happens here, can be one time/permanent update/function/time dependent/animates/user input... etc
//      +   renderPassDescriptor //structure for begin: like glClear/glEnable(?)
//      |   update uniforms
//      |   create commandEncoder // like glBegin //is destroyed after use, fresh one needed for each frame
//      |   passEncoder = commandEncoder.beginRenderPass renderPassDescriptor (starts here with above init structures) :const
//      |      passEncoder.setPipeline     (renderPipeline);  // bind program?
//      |      passEncoder.setVertexBuffer (0/2/3..., vertexBuffer); // bind vao?
//      |      passEncoder.setBindGroup    (0, bindGroup); //  bind uniforms
//      |      passEncoder.draw(numvertices...);
//      |      passEncoder.end();
//      |   commandEncoder.finish()
//      +   ends with device.queue.submit([commandEncoder.finish()]); //end device
/////   end while (draw)
   </pre>
   This WebGPU sample migrated from <a href="./draw.simple.1.glsl300.html">this WebGL (cones fully consolidated)</a><br/>
   Same WebGL <a href="./draw.simple.1.glsl300.vao.html">With VAO (not consolidated)</a><br/>
   <div class="sample">
      WebGPU very simple<br/>
      Color background<br/>
      <canvas width="120" height="120" class="green">
         <script src="./webgpu1/simple.js"></script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU triangle 1:<br/>
      Strided Buffers<br/>
      <canvas width="160" height="120">
         <script src="./webgpu1/basicTriangleStridedBuffers.js" defer=""></script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU triangle:<br/>
      Separated Buffers<br/>
      <canvas width="160" height="120">
         <script src="./webgpu1/basicTriangleSeparatedBuffers.js" defer=""></script>
      </canvas>
   </div><br/>
   <div class="sample">
      WebGPU triangle<br/>
      Depth: Direct Z<br/>
      Try Classes:<br/>
      html/script shaders<br/>
      <canvas width="160" height="120">
        <script src="./webgpu1/basicTwoTrianglesPerspectie_TryClasses.js" defer=""></script>
        <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin(position) position : vec4f,
               @location(0) color : vec4f
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) color: vec4f) -> VertexOut
            {
               var output : VertexOut;
               output.position = position;
               output.color    = color;
               return output;
            }
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               return fragData.color;
            }
        </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU triangle<br/>
      Depth: Inveted Z<br/>
      Try Classes2:<br/>
      html/script shaders<br/>
      <canvas width="160" height="120">
        <script src="./webgpu1/basicTwoTrianglesPerspectie2_TryClasses..js" defer=""></script>
        <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin(position) position : vec4f,
               @location(0) color : vec4f
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) color: vec4f) -> VertexOut
            {
               var output : VertexOut;
               output.position = position;
               output.color    = color;
               return output;
            }
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               return fragData.color;
            }
        </script>
      </canvas>
   </div><br/>
   <div class="sample">
      WebGPU Simple draw:<br/>
      <canvas width="120" height="120" class="blue">
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin(position) position : vec4f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec2f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4f(position, 0, 1);
               return ret;
            }
            @fragment
            fn fragment_main() -> @location(0) vec4f
            {
               //return vec4f(0.0, 1.0, 1.0, 0.5); //keep it as of now
               return vec4f(0.0, 0.0, 0.0, 0.1);
            }
        </script>
         <script src="./webgpu1/simpleDraw.js"></script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU Simple indexed:<br/>
      <canvas id="simpleDrawIndexed"  width="120" height="120" class="blue">
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin(position) position : vec4f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec2f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4f(position, 0, 1);
               return ret;
            }
            @fragment
            fn fragment_main() -> @location(0) vec4f
            {
               return vec4f(1.0, 0.0, 1.0, 0.5);
            }
         </script>
         <script src="./webgpu1/simpleDrawIndexed.js"></script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU Translate:<br/>
      <canvas id="translate"  width="120" height="120" class="yellow">
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin(position) position : vec4f,
            }
            const translation = vec4f(0.5, 0.5, 0.0, 0.0);
            @vertex
            fn vertex_main(@location(0) position: vec4f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position + translation; //hardcoded translation
               return ret;
            }
            @fragment
            fn fragment_main() -> @location(0) vec4f
            {
               return vec4f(0.0, 1.0, 0.0, 1.0);
            }
         </script>
         <script src="./webgpu1/translate.js"></script>
      </canvas>
   </div><br/>
   <!-- Go big for screen snippets -->
   <div class="sample">
      WebGPU<br/>
      webgl space mess<br/>
      Translate animate 1:<br/>
      <canvas id = "animate"  width="120" height="120" class="cyan">
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VSUniforms {
               translation: vec4f,
            };
            @group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;
            struct VertexOut
            {
               @builtin(position) position : vec4f,
            }
            @vertex
            fn vertex_main (@location(0) position: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4f (position, 1) + vsUniforms.translation;
               return ret;
            }
            @fragment
            fn fragment_main () -> @location(0) vec4f
            {
               return vec4f(0.0, 0.0, 0.0, 0.1);
            }
         </script>
         <script src="./webgpu1/animate.js"></script>
      </canvas>
   </div>
   <div class="sample" >
      WebGPU<br/>
      webgl to webgpu space<br/>
      Translate animate 2:<br/>
      <canvas id = "animate second instance" width="120" height="120" class="magenta">
          <script src="./webgpu1/animate2.js"></script>
          <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VSUniforms {
               translation: vec4f,
            };
            @group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;
            struct VertexOut
            {
               @builtin(position) position : vec4f,
            }
            @vertex
            fn vertex_main (@location(0) position: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4f (position, 1) + vsUniforms.translation;
               return ret;
            }
            @fragment
            fn fragment_main () -> @location(0) vec4f
            {
               return vec4f(0.0, 0.0, 0.0, 0.1);
            }
         </script>

      </canvas>
   </div>
   <div class="sample">
      WebGPU Normals:<br/>
      Separated Buffers<br/>
      <canvas id = "normals" width = "120" height = "120"  class="yellow">
         <script src="./webgpu1/normals.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec3f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4(position, 1.0);
               ret.normal   = normal;
               return ret;
            }
            const lightDirection = normalize (vec3(-1.0,  -1.0,  1.0)); // Direction -> to left down forward
            const greenColor     = vec3      (0.0,  1.0,  0.0);         // RGB of green
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod   =  -dot (lightDirection,   normalize(fragData.normal));
               return vec4 (greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU: Colors R+G:<br/>
      Strided Buffers<br/>
      <canvas id="usecolors" width="120" height="120"  class="yellow">
          <script src="./webgpu1/usecolors.js"></script>
          <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        color    : vec4f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec3f, @location(1) color: vec4f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4(position, 1.0);
               ret.color    = color;
               return ret;
            }
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               return fragData.color;
            }
         </script>
      </canvas>
   </div><br/>
   <div class="sample">
      WebGPU (ok with inversion)<br/>
      Cone TRIANGLE_FAN<br/>
      Perspective direct lefthanded<br/>
      (wrong but correct, glow effect)</br>
      <canvas id = "cone" width = "200" height = "200"  class="yellow">
         <script src="./webgpu1/triangleFan.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec3f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4(position, 1.0);
               ret.normal   = normal;
               return ret;
            }
            const constLightDirection = vec3 (0.0, 1.2, 0.0);      // Direction -> to center down forward
            const constColor          = vec4 (0.0, 1.0, 0.0, 0.1); // Green Color
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod =  -dot (constLightDirection,  fragData.normal );
               return vec4 (constColor.rgb * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU (ok with inversion)<br/>
      Cone TRIANGLE_FAN 2<br/>
      Perspective inverse righthanded<br/>
      (wrong bur correct, glow effect)</br>
      <canvas id = "cone" width = "200" height = "200"  class="yellow">
         <script src="./webgpu1/triangleFan2.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec3f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = vec4(position, 1.0);
               ret.normal   = normal;
               return ret;
            }
            const constLightDirection = vec3 (0.0, 1.2, 0.0);      // Direction -> to center down forward
            const constColor          = vec4 (0.0, 1.0, 0.0, 0.1); // Green Color
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod =  -dot (constLightDirection,  fragData.normal );
               return vec4 (constColor.rgb * prod,  1.0);
            }
         </script>
      </canvas>
   </div><br/>
   <div class="sample">
      WebGPU: Cone TRIANGLES (correct), <br/>
      Normals simple, smooth gradient<br/>
      Tip normal set to 0,0,0<br/>
      Light change direction<br/>
      <canvas id = "cone1_animate" width = "360" height = "360"  class="yellow">
         <script src="./webgpu1/cone1Animate.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f
            }
            struct VSUniforms { lightDirection: vec2f };
            @group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor = vec3(0.0,  1.0,  0.0);
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod      = -dot (normalize(vec3(vsUniforms.lightDirection, 1.0)), normalize(fragData.normal));
               return vec4(greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU, Cone TRIANGLES (correct), <br/>
      Normals simple cross prod<br/>
      Tip normal set to one side normal.<br/>
      Light change direction<br/>
      <canvas id = "cone1_animate" width = "360" height = "360"  class="yellow">
         <script src="./webgpu1/cone1Animate2.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            struct VSUniforms { lightDirection: vec2f };
            @group(0) @binding(0) var<uniform> vsUniforms: VSUniforms;
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor = vec3(0.0,  1.0,  0.0);
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod = -dot (normalize(vec3(vsUniforms.lightDirection, 1.0)), normalize(fragData.normal));
               return vec4(greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div><br/>
   <br/>
   <div class="sample">
      WebGPU:</br>
      Cone 1 geometry 1, </br>
      Smooth, </br>
      Verts as normals<br/>
      <canvas id = "cone1" width = "200" height = "200"  class="yellow">
         <script src="./webgpu1/cone1Geometry1.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor     =  vec3 (0.0,  1.0,  0.0);              // RGB of green
            const lightDirection =  normalize (vec3(-1.0,  -1.0,  1.0)); // Direction -> to left down forward, z lefthanded
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod = -dot (lightDirection,   normalize(fragData.normal));
               return vec4 (greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU</br>
      Cone 1 geometry 2, </br>
      cross normals<br/>
      <canvas id = "cone1_geometry" width = "200" height = "200"  class="yellow">
         <script src="./webgpu1/cone1Geometry2.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor     =  vec3 (0.0,  1.0,  0.0);             // RGB of green
            const lightDirection =  normalize (vec3(-1.0,  -1.0, 1.0)); // Direction -> to left down forward, z lefthanded
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod = -dot (lightDirection,   normalize(fragData.normal));
               return vec4 (greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU</br>
      Cone 1 geometry 3</br>
      Geometry borrow normals<br/>
      <canvas id = "cone1_geometry" width = "200" height = "200"  class="yellow">
         <script src="./webgpu1/cone1Geometry3.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor     =  vec3 (0.0,  1.0,  0.0);               // RGB of green
            const lightDirection =  normalize (vec3(-1.0,  -1.0,   1.0)); // Direction -> to left down forward, z lefthanded
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod = -dot (lightDirection,   normalize(fragData.normal));
               return vec4 (greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div><br/>
   <div class="sample">
      WebGPU: face culling</br>
      Hearth Cone, </br>
      Geometry left (cross) <br/>
      <canvas id = "cone1 heart geometry" width = "200" height = "200"  class="yellow">
         <script src="./webgpu1/cone1HeartGeometry.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor     =  vec4 (0.0,  1.0,  0.0, 1.0);              // RGBA of green
            const lightDirection =  normalize (vec3(-1.0,  -1.0, 1.0)); // Direction -> to left down forward
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod = -dot (normalize(fragData.normal), lightDirection  );
               return vec4 (greenColor.rgb  * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <div class="sample">
      WebGPU, face culling</br>
      Hearth Cone Triangles, </br>
      Geometry, gradient<br/>
      <canvas id = "cone1 heart geometry" width = "400" height = "400"  class="yellow">
         <script src="./webgpu1/cone1HeartGeometry2.js"></script>
         <script type="text/wgsl-shader" data-gpu-type="webgpu-shader">
            struct VertexOut
            {
               @builtin  (position) position : vec4f, //builtin cannot be changed
               @location (0)        normal   : vec3f,
            }
            @vertex
            fn vertex_main(@location(0) position: vec4f, @location(1) normal: vec3f) -> VertexOut
            {
               var ret : VertexOut;
               ret.position = position;
               ret.normal   = normal;
               return ret;
            }
            const greenColor     =  vec3 (0.0,  1.0,  0.0);              // RGB of green
            const lightDirection =  normalize (vec3(-1.0,  -1.0, 1.0)); // Direction -> to left down forward z:lefthanded, points into deep
            @fragment
            fn fragment_main(fragData: VertexOut) -> @location(0) vec4f
            {
               let prod = -dot (normalize(fragData.normal), lightDirection);
               return vec4 (greenColor * prod,  1.0);
            }
         </script>
      </canvas>
   </div>
   <br/>
   <canvas id = "mycanvas1"  width = "310" height =  "40" class = "red"  ><script src="./webgpu1/2d.js"    ></script></canvas>
   <a href="./tutorials.html">Tutorials</a>
</body>
</html>